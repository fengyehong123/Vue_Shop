## 组件之间共享数据的方式
> 父组件向子组件传值
`v-bind`属性绑定

> 子组件向父组件传值
`v-on`事件绑定

> 兄弟组件之间共享数据
`EventBus`
- `$on`: *接收数据的那个组件*
- `$emit`: *发送数据的那个组件*

上面三种方式只适合于小范围内的数据共享,不适合于大范围内的数据共享
为了解决这个问题,推出了Vuex

## Vuex
Vuex是实现组件全局状态(数据)管理的一种机制,可以方便的实现*组件之间的数据共享*
> 使用Vuex统一管理的好处
- 能够在vuex中集中管理共享的数据,易于开发和后期维护
- 能够高效的实现组件之间的数据共享,提高开发效率
- 存储在vuex中的数据都是响应式的,能够实时保持数据与页面的同步

### 什么样的数据适合存储到vuex中
一般情况下,只有组件之间共享数据,才有必要存储到vuex中;
对于组件中的私有数据,依旧存储在组件自身的data中即可.

### Vuex的基本使用
1. 安装Vuex依赖包
`npm install vuex --save`
2. 导入vuex包
```js
    import Vuex from 'vuex''
    Vue.use(Vuex)
```
3. 创建store对象
```js
    const store = new Vuex.Store({
        // state中存放的就是全局共享的数据
        state: {count: 0}
    })
```
4. 将store对象挂载到vue实例中
```js
    new Vue({
        el: '#app',
        render: h => h(app),
        router,
        // 将创建的共享数据对象挂载到vue实例中.所有的组件就可以直接从store中获取全局的数据了
        store
    })
```

### Vuex中的核心概念
- ⭕State
> `state`提供唯一的公共数据源,所有共享的数据都要统一放到Store的State中进行存储
```js
    const store = new Vuex.Store({
        state: {count: 0}
    })
```
🐞组件访问State中数据的*第一种方式*:
`this.$store.state.全局数据名称(count)`
🐞组件访问State中数据的*第二种方式*:
```js
    // 1. 从vuex中按需导入mapState函数
    import { mapState } from 'vuex'

    // 2. 将刚才导入的mapSate函数,将当前组件需要的全局数据,映射为当前组件的computed计算属性
    computed: {
        // 将全局属性映射为当前组件的计算属性 
        ...mapState(['count'])
    }
```
- ⭕Mutation
> Mutation用于变更Store中的数据

*触发mutations的第一种方式*
😈 只能`通过mutation变更Store数据`,不可以直接操作Store中的数据
😈 通过mutation的方式虽然操作起来繁琐一点,但是可以集中监控所有数据的变化,明确数据被哪个方法修改
```js
    const store = new Vuex.Store({
        state: {count: 0}
    }),
    // 在vuex中定义Mutation
    mutations: {
        add(state) {
            // 变更状态
            state.count++
        }
    }
```
```js
    // 在其他组件中触发mutation
    methods: {
        handle1() {
            // 触发mutations的第一种方式
            this.$store.commit('add')
        }
    }
```
> 可以在触发mutations时传递参数
```js
    const store = new Vuex.Store({
        state: {count: 0}
    }),
    // 在vuex中定义Mutation
    mutations: {
        addN(state, step) {
            // 变更状态
            state.count += step
        }
    }
```
```js
    // 在其他组件中触发mutation,并携带参数
    methods: {
        handle2() {
            // 调用commit函数,触发mutations时携带参数
            this.$store.commit('addN', 3)
        }
    }
```
*触发mutations的第二种方式*
```js
    // 从vuex中按需导入 mapMutations函数
    import { mapMutations } from 'vuex'

    // 通过刚才导入的mapMutations函数,映射为当前组件的methods函数
    methods: {
        ...mapMutations(['add', 'addN'])
    }
```

- ⭕Action
> Action用于处理异步任务
*触发Action的第一种方式*
如果通过异步操作变更数据,必须通过Action,而不能使用Mutation,
但是在Action中还是要通过触发Mutation的方式`间接变更数据`
```js
    const store = new Vuex.Store({
        // ...省略其它代码
        mutations: {
            add(state) {
                state.count++
            }
        },
        actions: {
            // 我们定义一个异步函数addAsync
            addAsync(context) {
                setTimeout(() => {
                    // 把add()方法包裹在异步操作的代码中,从而实现在Action中触发mutations中的方法
                    context.commit('add')
                }, 1000)
            }
        }
    })
```
```js
    // 触发Action
    methods: {
        handle() {
            // 触发actions的第一种方式
            this.$store.dispatch('addAsync')
        }
    }
```
*触发Action的第二种方式*
```js
    // 从vuex中按需导入mapActions函数
    import { mapActions } from 'vuex'

    // 将指定的actions函数,映射为当前组件的methods函数
    methods: {
        ...mapActions(['addAsync', 'addNAsync'])
    }
```
- ⭕Getter
> `Getter`用于对Store中的数据进行加工处理形成新的数据,Getter并不会改变Store中的数据,只是对其加工处理而已
🔹 Getter可以对Store中已有的数据进行加工处理,处理完成之后形成新的数据,类似Vue的计算属性
🔹 Store中的数据发生变化,Getter包装处理之后的数据也会随之发生变化
```js
    const store = new Vuex.Store({
        state: {
            count: 0
        },
        getters: {
            showNum: state => {
                // getter并不会修改store中的数据,只是对store中的数据进行包装处理
                return '当前最新的数量是「'+ state.count +'」'
            }
        }
    }),
```
- 🛸使用getters的第一种方式
`this.$store.getters.名称`
- 🛸使用getters的第二种方式
```js
    import { mapGetters } from 'vuex'

    computed: {
        ...mapGetters(['showNum'])
    }
```
